import base64
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.x509 import load_pem_x509_certificate
from datetime import datetime
import os

private_key_path = os.environ["SIGNING_PRIVATE_KEY_PATH"]
x509_certificate_path = os.environ["SIGNING_CERT_PATH"]
dummy_signature = "DQo8U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj4NCiAgICA8U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyI"

DIGEST_PLACEHOLDER = "{{digest}}"
SIGNATURE_PLACEHOLDER = "{{signature}}"
CERT_PLACEHOLDER = "{{cert}}"

PRIVATE_KEY_EXISTS = os.path.exists(private_key_path)
X509_CERT_EXISTS = os.path.exists(x509_certificate_path)


def get_signature(digest: str, valid: bool):
    if not PRIVATE_KEY_EXISTS and X509_CERT_EXISTS:
        return dummy_signature

    # load cert and check expiry
    cert_data = get_path(x509_certificate_path)
    cert = load_pem_x509_certificate(cert_data, default_backend())
    if cert.not_valid_after < datetime.now():
        raise ValueError("Signing certificate has expired")

    # load private key and generate signature against digest
    private_key = serialization.load_pem_private_key(
        get_path(private_key_path), password=None
    )
    signature_bytes: bytes = private_key.sign(
        digest.encode("utf-8"), padding.PKCS1v15(), hashes.SHA256()
    )

    # align format with signature generated by ts code
    signature = base64.b64encode(signature_bytes).decode("ASCII")

    # load signature template and replace {{placeholders}}
    sign_data = get_path("./util/signature.txt")

    # decodes digest to xml
    decoded_digest = base64.b64decode(digest).decode("utf-8")

    digest_without_namespace = decoded_digest.replace(
        '<SignedInfo xmlns="http://www.w3.org/2000/09/xmldsig#">', "<SignedInfo>"
    )
    sign_data = sign_data.replace(DIGEST_PLACEHOLDER, digest_without_namespace)

    if valid:
        sign_data = sign_data.replace(SIGNATURE_PLACEHOLDER, signature)
    else:
        sign_data = sign_data.replace(
            SIGNATURE_PLACEHOLDER, f"{signature}TVV3WERxSU0xV0w4ODdRRTZ3O"
        )

    # get the raw value to certificate_value???
    certificate_value = base64.b64encode(cert_data).decode()
    sign_data = sign_data.replace(CERT_PLACEHOLDER, certificate_value)

    # this might be a breaking change
    signature = base64.b64encode(sign_data, "utf-8")

    return signature


def get_path(path):
    with open(path, "rb") as f:
        doc = f.read()
    return doc
